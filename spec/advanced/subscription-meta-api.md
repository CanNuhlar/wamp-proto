### Subscriber Meta Events

Support for this feature MUST be announced by *Subscribers* (`role := "subscriber"`) and *Brokers* (`role := "broker"`) via

    HELLO.Details.roles.<role>.features.subscriber_metaevents|bool := true

*Example*

    [32, 713845233,
         {"metatopics": ["wamp.metatopic.subscriber.add",
                         "wamp.metatopic.subscriber.remove"]},
         "com.myapp.mytopic1"]

If above subscription request by a *Subscriber 1* succeeds, the *Broker* will dispatch meta events to *Subscriber 1* for every *Subscriber 2, 3, ..* added to or removed from a subscription for `com.myapp.mytopic1`. It will also dispatch "normal" events on the topic `com.myapp.mytopic1` to *Subscriber 1*.

*Example*

    [32, 713845233,
         {"metatopics": ["wamp.metatopic.subscriber.add",
                         "wamp.metatopic.subscriber.remove"],
          "metaonly": 1},
         "com.myapp.mytopic1"]

This subscription works like the previous one, except that "normal" events on the topic `com.myapp.mytopic1` will NOT be dispatched to *Subscriber 1*. Consequently, it is called a "Meta Event only subscription".


Metaevents are always generated by the *Broker* itself and do not contain application payload:

    [EVENT, SUBSCRIBED.Subscription|id, PUBLISHED.Publication|id, Details|dict]

*Example*

    [36, 5512315355, 71415664, {"metatopic": "wamp.metatopic.subscriber.add", "session": 9712478}]

*Example*

    [36, 5512315355, 71415664, {"metatopic": "wamp.metatopic.subscriber.remove", "session": 9712478}]


The following metatopics are currently defined:

 1. `wamp.metatopic.subscriber.add`: A new subscriber is added to the subscription.
 2. `wamp.metatopic.subscriber.remove`: A subscriber is removed from the subscription.


### Subscriber Events

Write me.


### Subscriber Listing

A *Broker* may allow to retrieve the current list of *Subscribers* for a given subscription.

Support for this feature MUST be announced by *Subscribers* (`role := "subscriber"`) and *Brokers* (`role := "broker"`) via

    HELLO.Details.roles.<role>.features.subscriber_list|bool := true

A *Broker* that implements *subscriber list* must (also) announce role `HELLO.roles.callee` and provide the following (built in) procedures.

A *Caller* (that is also a *Subscriber*) can request the current list of subscribers for a subscription (it is subscribed to) by calling the *Broker* procedure

    wamp.broker.subscriber.list

with `Arguments = [subscription|id]` where

 * `subscription` is the ID of the subscription as returned from `SUBSCRIBED.Subscription`

and `Result = sessions|list` where

 * `sessions` is a list of WAMP session IDs currently subscribed to the given subscription.

A call to `wamp.broker.subscriber.list` may fail with

    wamp.error.no_such_subscription
    wamp.error.not_authorized

**Open Issues**

 1. What if we have multiple *Brokers* (a cluster)? The call would need to be forwarded.
 2. Should we allow "paging" (`offset|integer` and `limit|integer` arguments)?
 3. Should we allow *Subscribers* to list subscribers for subscription it is not itself subscribed to? How would the *Callee* know the subscription ID it wants to look up without subscribing?
 4. Why retrieve the list for a subscription ID, when the interest may lie in how many subscribers there are to a topic, e.g. if a publisher wants to judge its current reach?
 5. The *Router* needs to implement a *Dealer* role as well in order to be able to route the RPC, since calls can only be addressed to *Dealers*.
 6. We should probably then also have a *Callee* as a separate peer. Otherwise we break the rule that peers can implement Broker/Dealer OR Caller/Callee/Subscriber/Publisher roles.
 7. If we have the separate *Callee*, then how does this get the list? One way would be using subscription meta-events.
